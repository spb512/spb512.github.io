<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>123</title>
      <link href="//2434wer"/>
      <url>//2434wer</url>
      
        <content type="html"><![CDATA[<p><strong>setsasdaqweqw</strong></p><p><em>ggdfgdf fdsfds发顺丰的数据分类数据司法解释雷锋精神两地分居军绿色的空间里发觉上当了f23423</em></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL优化学习</title>
      <link href="/posts/a53dd44/"/>
      <url>/posts/a53dd44/</url>
      
        <content type="html"><![CDATA[<h1 id="查询速度慢的原因"><a href="#查询速度慢的原因" class="headerlink" title="查询速度慢的原因"></a>查询速度慢的原因</h1><h2 id="流程上的慢"><a href="#流程上的慢" class="headerlink" title="流程上的慢"></a>流程上的慢</h2><p>执行查询时间花费在网络、cpu计算、生成统计信息、执行计划、锁等待（互斥等待）这些环节，任何一个环节都有可能是慢的原因。</p><h2 id="不合理操作"><a href="#不合理操作" class="headerlink" title="不合理操作"></a>不合理操作</h2><p>在每一个消耗大量时间的查询案例中，我们都能看到一些不必要的额外操作、某些操作被额外地重复了很多次、某些操作执行得太慢等。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>减少和消除这些操作所花费的时间。</p><h1 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h1><p>分析步骤：</p><pre><code>1、确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。2、确认MySQL服务器层是否在分析大量超过需要的数据行。</code></pre><h2 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h2><p>例如：</p><ul><li>查询不需要的记录。一个常见的错误是常常会误以为MySQL会只返回需要的数据，实际上MySQL却是先返回全部结果集再进行计算。</li><li>多表关联时返回全部列。每次看到SELECT *的时候都需要用怀疑的眼光审视，是不是真的需要返回全部的列？很可能不是必需的。取出全部列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的I/O、内存和CPU的消耗。</li><li>重复查询相同的数据。</li></ul><h2 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h2><p>在确定查询只返回需要的数据以后，接下来应该看看查询为了返回结果是否扫描了过多的数据。对于MySQL，最简单的衡量查询开销的三个指标如下：</p><ul><li>响应时间</li><li>扫描的行数</li><li>返回的行数<br>这三个指标都会记录到MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法。</li></ul><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>响应时间是两个部分之和：服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间——可能是等I/O操作完成，也可能是等待行锁，等等。一般最常见和重要的等待是I/O和锁等待，但是实际情况更加复杂。</p><p>当你看到一个查询的响应时间的时候，首先需要问问自己，这个响应时间是否是一个合理的值。（了解这个查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机I/O，再用其乘以在具体硬件条件下一次I/O的消耗时间。最后把这些消耗都加起来，就可以获得一个大概参考值来判断当前响应时间是不是一个合理的值。）</p><h2 id="扫描的行数和返回的行数"><a href="#扫描的行数和返回的行数" class="headerlink" title="扫描的行数和返回的行数"></a>扫描的行数和返回的行数</h2><p>理想情况下扫描的行数和返回的行数应该是相同的。但实际情况中这种“美事”并不多。例如在做一个关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在1:1和10:1之间，不过有时候这个值也可能非常非常大。</p><h2 id="扫描的行数和访问类型"><a href="#扫描的行数和访问类型" class="headerlink" title="扫描的行数和访问类型"></a>扫描的行数和访问类型</h2><p>在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySQL有好几种访问方式可以查找并返回一行结果。</p><p>在EXPLAIN语句中的type列反应了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。这里列的这些，速度是从慢到快，扫描的行数也是从小到大。</p><p>如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引。</p><p>MySQL能够使用如下三种方式应用WHERE条件，从好到坏依次为：</p><ul><li>在索引中使用WHERE条件来过滤不匹配的记录。这是在存储引擎层完成的。</li><li>使用索引覆盖扫描（在Extra列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务器层完成的，但无须再回表查询记录。</li><li>从数据表中返回数据，然后过滤不满足条件的记录（在Extra列中出现Using Where）。这在MySQL服务器层完成，MySQL需要先从数据表读出记录然后过滤。</li></ul><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><ul><li>使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了。</li><li>改变库表结构。例如使用单独的汇总表。</li><li>重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。</li></ul><h1 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h1><p>在优化有问题的查询时，目标应该是找到一个更优的方法获得实际需要的结果——而不一定总是需要从MySQL获取一模一样的结果集。有时候，可以将查询转换一种写法让其返回一样的结果，但是性能更好。但也可以通过修改应用代码，用另一种方式完成查询，最终达到一样的目的。</p><h2 id="一个复杂查询还是多个简单查询"><a href="#一个复杂查询还是多个简单查询" class="headerlink" title="一个复杂查询还是多个简单查询"></a>一个复杂查询还是多个简单查询</h2><p>在传统实现中，总是强调需要数据库层完成尽可能多的工作，这样做的逻辑在于以前总是认为网络通信、查询解析和优化是一件代价很高的事情。但是这样的想法对于现在的MySQL并不适用了，现代的网络速度比以前要快很多，无论是带宽还是延迟。所以运行多个小查询现在已经不是大问题了。<br>根据情况自行选择。</p><h2 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h2><p>对于一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。</p><p>时间上一定频率的执行，数量上分多次执行。</p><h2 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h2><p>很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>让缓存的效率更高。</li><li>将查询分解后，执行单个查询可以减少锁的竞争。</li><li>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。</li><li>查询本身效率也可能会有所提升。（例如使用IN()代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联要更高效。）</li><li>可以减少冗余记录的查询。</li><li>这样做相当于在应用中实现了哈希关联，而不是使用MySQL的嵌套循环关联。</li></ul><h1 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h1><p>查询过程：</p><p>1、客户端发送一条查询给服务器。</p><p>2、服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</p><p>3、服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划。</p><p>4、MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。</p><p>5、将结果返回给客户端。</p><h2 id="MySQL客户端-x2F-服务器通信协议"><a href="#MySQL客户端-x2F-服务器通信协议" class="headerlink" title="MySQL客户端/服务器通信协议"></a>MySQL客户端/服务器通信协议</h2><p>MySQL客户端和服务器之间的通信协议是“半双工”的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。</p><p>当客户端从服务器取数据时，看起来是一个拉数据的过程，但实际上是MySQL在向客户端推送数据的过程。客户端不断地接收从服务器推送的数据，客户端也没法让服务器停下来。客户端像是“从消防水管喝水”（这是一个术语）。</p><p>多数连接MySQL的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。</p><h3 id="查询状态"><a href="#查询状态" class="headerlink" title="查询状态"></a>查询状态</h3><p>使用SHOW FULL PROCESSLIST命令（该命令返回结果中的Command列就表示当前的状态）。</p><ul><li>Sleep线程正在等待客户端发送新的请求。</li><li>Query线程正在执行查询或者正在将结果发送给客户端。</li><li>Locked在MySQL服务器层，该线程正在等待表锁。在存储引擎级别实现的锁，例如InnoDB的行锁，并不会体现在线程状态中。对于MyISAM来说这是一个比较典型的状态，但在其他没有行锁的引擎中也经常会出现。</li></ul><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。如果权限没有问题，MySQL会跳过所有其他阶段，直接从缓存中拿到结果并返回给客户端。这种情况下，查询不会被解析，不用生成执行计划，不会被执行。</p><h2 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h2><p>查询的生命周期的下一步是将一个SQL转换成一个执行计划，MySQL再依照这个执行计划和存储引擎进行交互。这包括多个子阶段：解析SQL、预处理、优化SQL执行计划。</p><h2 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="headerlink" title="语法解析器和预处理"></a>语法解析器和预处理</h2><p>首先，MySQL通过关键字将SQL语句进行解析，并生成一棵对应的“解析树”。MySQL解析器将使用MySQL语法规则验证和解析查询。例如，它将验证是否使用错误的关键字，或者使用关键字的顺序是否正确等，再或者它还会验证引号是否能前后正确匹配。</p><p>预处理器则根据一些MySQL规则进一步检查解析树是否合法，例如，这里将检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义。</p><p>下一步预处理器会验证权限。这通常很快，除非服务器上有非常多的权限配置。</p><h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p>一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。</p><p>有很多种原因会导致MySQL优化器选择错误的执行计划，如下所示：</p><ul><li>统计信息不准确。</li><li>执行计划中的成本估算不等同于实际执行的成本。</li><li>MySQL的最优可能和你想的最优不一样。</li><li>MySQL从不考虑其他并发执行的查询，这可能会影响到当前查询的速度。</li><li>MySQL也并不是任何时候都是基于成本的优化。</li><li>MySQL不会考虑不受其控制的操作的成本，例如执行存储过程或者用户自定义函数的成本。</li><li>无法去估算所有可能的执行计划。</li></ul><h3 id="MySQL能够处理的优化类型："><a href="#MySQL能够处理的优化类型：" class="headerlink" title="MySQL能够处理的优化类型："></a>MySQL能够处理的优化类型：</h3><ul><li>重新定义关联表的顺序。</li><li>将外连接转化成内连接。</li><li>使用等价变换规则。</li><li>预估并转化为常数表达式。</li><li>覆盖索引扫描。（索引中的列包含所有查询中需要使用的列的时候，MySQL就可以使用索引返回需要的数据，而无须查询对应的数据行）。</li><li>子查询优化。</li><li>提前终止查询。</li><li>等值传播。</li><li>列表IN()的比较</li></ul><h3 id="MySQL有如下两种排序算法："><a href="#MySQL有如下两种排序算法：" class="headerlink" title="MySQL有如下两种排序算法："></a>MySQL有如下两种排序算法：</h3><ul><li>两次传输排序（旧版本使用）</li><li>单次传输排序（新版本使用）</li></ul><h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>相对于查询优化阶段，查询执行阶段不是那么复杂：MySQL只是简单地根据执行计划给出的指令逐步执行。</p><h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>查询执行的最后一个阶段是将结果返回给客户端。即使查询不需要返回结果集给客户端，MySQL仍然会返回这个查询的一些信息，如该查询影响到的行数。</p><p>如果查询可以被缓存，那么MySQL在这个阶段也会将结果存放到查询缓存中。</p><h1 id="MySQL查询优化器的局限性"><a href="#MySQL查询优化器的局限性" class="headerlink" title="MySQL查询优化器的局限性"></a>MySQL查询优化器的局限性</h1><h2 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h2><p>MySQL的子查询实现得非常糟糕。最糟糕的一类查询是WHERE条件中包含IN()的子查询语句。一般会建议使用左外连接（LEFT OUTER JOIN）重写该查询，以代替子查询。</p><h2 id="UNION的限制"><a href="#UNION的限制" class="headerlink" title="UNION的限制"></a>UNION的限制</h2><p>MySQL无法将限制条件从外层“下推”到内层，这使得原本能够限制部分返回结果的条件无法应用到内层查询的优化上。如果希望UNION的各个子句能够根据LIMIT只取部分结果集，或者希望能够先排好序再合并结果集的话，就需要在UNION的各个子句中分别使用这些子句。</p><h2 id="索引合并优化"><a href="#索引合并优化" class="headerlink" title="索引合并优化"></a>索引合并优化</h2><p>当WHERE子句中包含多个复杂条件的时候，MySQL能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行。</p><h2 id="等值传递"><a href="#等值传递" class="headerlink" title="等值传递"></a>等值传递</h2><p>某些时候，等值传递会带来一些意想不到的额外消耗。例如，有一个非常大的IN()列表，而MySQL优化器发现存在WHERE、ON或者USING的子句，将这个列表的值和另一个表的某个列相关联。</p><p>那么优化器会将IN()列表都复制应用到关联的各个表中。通常，因为各个表新增了过滤条件，优化器可以更高效地从存储引擎过滤记录。但是如果这个列表非常大，则会导致优化和执行都会变慢。</p><h2 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h2><p>MySQL无法利用多核特性来并行执行查询。</p><h2 id="哈希关联"><a href="#哈希关联" class="headerlink" title="哈希关联"></a>哈希关联</h2><p>MySQL并不支持哈希关联——MySQL的所有关联都是嵌套循环关联。不过，可以通过建立一个哈希索引来曲线地实现哈希关联。如果使用的是Memory存储引擎，则索引都是哈希索引，所以关联的时候也类似于哈希关联。</p><h2 id="松散索引扫描"><a href="#松散索引扫描" class="headerlink" title="松散索引扫描"></a>松散索引扫描</h2><p>MySQL并不支持松散索引扫描，也就无法按照不连续的方式扫描一个索引。</p><h2 id="最大值和最小值优化"><a href="#最大值和最小值优化" class="headerlink" title="最大值和最小值优化"></a>最大值和最小值优化</h2><p>对于MIN()和MAX()查询，MySQL的优化做得并不好。<br>这里有一个例子：</p><pre><code>mysql&gt; SELECT MIN(actor_id) FROM sakila.actor WHERE first_name='PENELOPE';</code></pre><p>因为在first_name字段上并没有索引，因此MySQL将会进行一次全表扫描。如果MySQL能够进行主键扫描，那么理论上，当MySQL读到第一个满足条件的记录的时候，就是我们需要找的最小值了，因为主键是严格按照actor_id字段的大小顺序排列的。但是MySQL这时只会做全表扫描，我们可以通过查看SHOW STATUS的全表扫描计数<br>器来验证这一点。一个曲线的优化办法是移除MIN()，然后使用LIMIT来将查询重写如下：</p><pre><code>mysql&gt; SELECT actor_id FROM sakila.actor USE INDEX(PRIMARY)    -&gt; WHERE first_name = 'PENELOPE' LIMIT 1;</code></pre><p>这个策略可以让MySQL扫描尽可能少的记录数。如果你是一个完美主义者，可能会说这个SQL已经无法表达她的本意了。一般我们通过SQL告诉服务器我们需要什么数据，由服务器来决定如何最优地获取数据，不过在这个案例中，我们其实是告诉MySQL如何去获取我们需要的数据，通过SQL并不能一眼就看出我们其实是想要一个最小值。确实如此，有时候为了获得更高的性能，我们不得不放弃一些原则。</p><h2 id="在同一个表上查询和更新"><a href="#在同一个表上查询和更新" class="headerlink" title="在同一个表上查询和更新"></a>在同一个表上查询和更新</h2><p>MySQL不允许对同一张表同时进行查询和更新。</p><h1 id="查询优化器的提示（hint）"><a href="#查询优化器的提示（hint）" class="headerlink" title="查询优化器的提示（hint）"></a>查询优化器的提示（hint）</h1><p>如果对优化器选择的执行计划不满意，可以使用优化器提供的几个提示（hint）来控制最终的执行计划。</p><ul><li>HIGH_PRIORITY和LOW_PRIORITY</li></ul><p>这个提示告诉MySQL，当多个语句同时访问某一个表的时候，哪些语句的优先级相对高些、哪些语句的优先级相对低些。</p><ul><li>DELAYED</li></ul><p>这个提示对INSERT和REPLACE有效。MySQL会将使用该提示的语句立即返回给客户端，并将插入的行数据放入到缓冲区，然后在表空闲时批量将数据写入。</p><ul><li>STRAIGHT_JOIN</li></ul><p>这个提示可以放置在SELECT语句的SELECT关键字之后，也可以放置在任何两个关联表的名字之间。第一个用法是让查询中所有的表按照在语句中出现的顺序进行关联。第二个用法则是固定其前后两个表的关联顺序。 </p><ul><li>SQL_SMALL_RESULT和SQL_BIG_RESULT</li></ul><p>这两个提示只对SELECT语句有效。它们告诉优化器对GROUP BY或者DISTINCT查询如何使用临时表及排序。</p><ul><li>SQL_BUFFER_RESULT</li></ul><p>这个提示告诉优化器将查询结果放入到一个临时表，然后尽可能快地释放表锁。</p><ul><li>SQL_CACHE和SQL_NO_CACHE</li></ul><p>这个提示告诉MySQL这个结果集是否应该缓存在查询缓存中。</p><ul><li>SQL_CALC_FOUND_ROWS</li></ul><p>严格来说，这并不是一个优化器提示。它不会告诉优化器任何关于执行计划的东西。它会让MySQL返回的结果集包含更多的信息。查询中加上该提示MySQL会计算除去LIMIT子句后这个查询要返回的结果集的总数，而实际上只返回LIMIT要求的结果集。可以通过函数FOUND_ROW()获得这个值。</p><ul><li>FOR UPDATE和LOCK IN SHARE MODE</li></ul><p>这也不是真正的优化器提示。这两个提示主要控制SELECT语句的锁机制，但只对实现了行级锁的存储引擎有效。使用该提示会对符合查询条件的数据行加锁。</p><ul><li>USE INDEX、IGNORE INDEX和FORCE INDEX</li></ul><p>这几个提示会告诉优化器使用或者不使用哪些索引来查询记录（例如，在决定关联顺序的时候使用哪个索引）。</p><ul><li>optimizer_search_depth</li></ul><p>这个参数控制优化器在穷举执行计划时的限度。如果查询长时间处于“Statistics”状态，那么可以考虑调低此参数。</p><ul><li>optimizer_prune_level</li></ul><p>该参数默认是打开的，这让优化器会根据需要扫描的行数来决定是否跳过某些执行计划。</p><ul><li>optimizer_switch</li></ul><p>这个变量包含了一些开启/关闭优化器特性的标志位。</p><h1 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h1><h2 id="优化COUNT-查询"><a href="#优化COUNT-查询" class="headerlink" title="优化COUNT()查询"></a>优化COUNT()查询</h2><p>COUNT()是一个特殊的函数，有两种非常不同的作用：它可以统计某个列值的数量，也可以统计行数。在统计列值时要求列值是非空的（不统计NULL）。如果在COUNT()的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。因为很多人对NULL理解有问题，所以这里很容易产生误解。</p><p>COUNT()的另一个作用是统计结果集的行数。当MySQL确认括号内的表达式值不可能为空时，实际上就是在统计行数。最简单的就是当我们使用COUNT（<em>）的时候，这种情况下通配符</em>并不会像我们猜想的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计所有的行数。</p><p><code>没有任何WHERE条件的COUNT（*）才非常快</code><br>优化：</p><ul><li>使用近似值</li></ul><p>有时候某些业务场景并不要求完全精确的COUNT值，此时可以用近似值来代替。EXPLAIN出来的优化器估算的行数就是一个不错的近似值，执行EXPLAIN并不需要真正地去执行查询，所以成本很低。</p><ul><li>简单的优化</li></ul><p>有时候可以使用MyISAM在COUNT（*）全表非常快的这个特性，来加速一些特定条件的COUNT()的查询。</p><ul><li>更复杂的优化</li></ul><p>通常来说，COUNT()都需要扫描大量的行（意味着要访问大量数据）才能获得精确的结果，因此是很难优化的。除了前面的方法，在MySQL层面还能做的就只有索引覆盖扫描了。如果这还不够，就需要考虑修改应用的架构，可以增加汇总表（第4章已经介绍过），或者增加类似Memcached这样的外部缓存系统。可能很快你就会发现陷入到一个熟悉的困境，“快速，精确和实现简单”，三者永远只能满足其二，必须舍掉其中一个。</p><h2 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h2><ul><li>确保ON或者USING子句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。</li><li>确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化这个过程。</li><li>当升级MySQL的时候需要注意：关联语法、运算符优先级等其他可能会发生变化的地方。</li></ul><h2 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h2><p>关于子查询优化我们给出的最重要的优化建议就是尽可能使用关联查询代替</p><h2 id="优化GROUP-BY和DISTINCT"><a href="#优化GROUP-BY和DISTINCT" class="headerlink" title="优化GROUP BY和DISTINCT"></a>优化GROUP BY和DISTINCT</h2><p>在MySQL中，当无法使用索引的时候，GROUP BY使用两种策略来完成：使用临时表或者文件排序来做分组。对于任何查询语句，这两种策略的性能都有可以提升的地方。可以通过使用提示SQL_BIG_RESULT和SQL_SMALL_RESULT来让优化器按照你希望的方式运行。</p><p>优化GROUP BY WITH ROLLUP</p><p>分组查询的一个变种就是要求MySQL对返回的分组结果再做一次超级聚合。可以使用WITH ROLLUP子句来实现这种逻辑，但可能会不够优化。可以通过EXPLAIN来观察其执行计划，特别要注意分组是否是通过文件排序或者临时表实现的。然后再去掉WITH ROLLUP子句看执行计划是否相同。<br>很多时候，如果可以，在应用程序中做超级聚合是更好的，虽然这需要返回给客户端更多的结果。也可以在FROM子句中嵌套使用子查询，或者是通过一个临时表存放中间数据，然后和临时表执行UNION来得到最终结果。</p><p>最好的办法是尽可能的将WITH ROLLUP功能转移到应用程序中处理。</p><h2 id="优化LIMIT分页"><a href="#优化LIMIT分页" class="headerlink" title="优化LIMIT分页"></a>优化LIMIT分页</h2><p>在系统中需要进行分页操作的时候，我们通常会使用LIMIT加上偏移量的办法实现，同时加上合适的ORDER BY子句。如果有对应的索引，通常效率会不错，否则，MySQL需要做大量的文件排序操作。</p><h2 id="优化SQL-CALC-FOUND-ROWS"><a href="#优化SQL-CALC-FOUND-ROWS" class="headerlink" title="优化SQL_CALC_FOUND_ROWS"></a>优化SQL_CALC_FOUND_ROWS</h2><p>分页的时候，另一个常用的技巧是在LIMIT语句中加上SQL_CALC_FOUND_ROWS提示（hint），这样就可以获得去掉LIMIT以后满足条件的行数，因此可以作为分页的总数。看起来，MySQL做了一些非常“高深”的优化，像是通过某种方法预测了总行数。但实际上，MySQL只有在扫描了所有满足条件的行以后，才会知道行数，所以加上这个提示以后，不管是否需要，MySQL都会扫描所有满足条件的行，然后再抛弃掉不需要的行，而不是在满足LIMIT的行数后就终止扫描。所以该提示的代价可能非常高。</p><p>一个更好的设计是将具体的页数换成“下一页”按钮，假设每页显示20条记录，那么我们每次查询时都是用LIMIT返回21条记录并只显示20条，如果第21条存在，那么我们就显示“下一页”按钮，否则就说明没有更多的数据，也就无须显示“下一页”按钮了。</p><p>另一种做法是先获取并缓存较多的数据——例如，缓存1000条——然后每次分页都从这个缓存中获取。这样做可以让应用程序根据结果集的大小采取不同的策略，如果结果集少于1000，就可以在页面上显示所有的分页链接，因为数据都在缓存中，所以这样做性能不会有问题。如果结果集大于1000，则可以在页面上设计一个额外的“找到的结果多于1000条”之类的按钮。这两种策略都比每次生成全部结果集再抛弃掉不需要的数据的效率要高很多。</p><p>有时候也可以考虑使用EXPLAIN的结果中的rows列的值来作为结果集总数的近似值（实际上Google的搜索结果总数也是个近似值）。当需要精确结果的时候，再单独使用COUNT（*）来满足需求，这时如果能够使用索引覆盖扫描则通常也会比SQL_CALC_FOUND_ROWS快得多。</p><h2 id="优化UNION查询"><a href="#优化UNION查询" class="headerlink" title="优化UNION查询"></a>优化UNION查询</h2><p>MySQL总是通过创建并填充临时表的方式来执行UNION查询。因此很多优化策略在UNION查询中都没法很好地使用。经常需要手工地将WHERE、LIMIT、ORDER BY等子句“下推”到UNION的各个子查询中，以便优化器可以充分利用这些条件进行优化（例如，直接将这些子句冗余地写一份到各个子查询）。</p><p>除非确实需要服务器消除重复的行，否则就一定要使用UNION ALL，这一点很重要。如果没有ALL关键字，MySQL会给临时表加上DISTINCT选项，这会导致对整个临时表的数据做唯一性检查。这样做的代价非常高。即使有ALL关键字，MySQL仍然会使用临时表存储结果。事实上，MySQL总是将结果放入临时表，然后再读出，再返回给客户端。虽然很多时候这样做是没有必要的（例如，MySQL可以直接把这些结果返回给客户端）。</p><h2 id="静态查询分析"><a href="#静态查询分析" class="headerlink" title="静态查询分析"></a>静态查询分析</h2><p>Percona Toolkit中的pt-query-advisor能够解析查询日志、分析查询模式，然后给出所有可能存在潜在问题的查询，并给出足够详细的建议。这像是给MySQL所有的查询做一次全面的健康检查。</p><h2 id="使用用户自定义变量"><a href="#使用用户自定义变量" class="headerlink" title="使用用户自定义变量"></a>使用用户自定义变量</h2><p>用户自定义变量是一个容易被遗忘的MySQL特性，但是如果能够用好，发挥其潜力，在某些场景可以写出非常高效的查询语句。在查询中混合使用过程化和关系化逻辑的时候，自定义变量可能会非常有用。单纯的关系查询将所有的东西都当成无序的数据集合，并且一次性操作它们。MySQL则采用了更加程序化的处理方式。MySQL的这种方式有它的弱点，但如果能熟练地掌握，则会发现其强大之处，而用户自定义变量也可以给这种方式带来很大的帮助。</p><p>哪些场景下我们不能使用用户自定义变量：</p><ul><li>使用自定义变量的查询，无法使用查询缓存。</li><li>不能在使用常量或者标识符的地方使用自定义变量，例如表名、列名和LIMIT子句中。</li><li>用户自定义变量的生命周期是在一个连接中有效，所以不能用它们来做连接间的通信。</li><li>如果使用连接池或者持久化连接，自定义变量可能让看起来毫无关系的代码发生交互（如果是这样，通常是代码bug或者连接池bug，这类情况确实可能发生）。</li><li>在5.0之前的版本，是大小写敏感的，所以要注意代码在不同MySQL版本间的兼容性问题。</li><li>不能显式地声明自定义变量的类型。确定未定义变量的具体类型的时机在不同MySQL版本中也可能不一样。如果你希望变量是整数类型，那么最好在初始化的时候就赋值为0，如果希望是浮点型则赋值为0.0，如果希望是字符串则赋值为’’，用户自定义变量的类型在赋值的时候会改变。MySQL的用户自定义变量是一个动态类型。</li><li>MySQL优化器在某些场景下可能会将这些变量优化掉，这可能导致代码不按预想的方式运行。</li><li>赋值的顺序和赋值的时间点并不总是固定的，这依赖于优化器的决定。</li></ul><p>用户自定义变量的其他用处：</p><ul><li>查询运行时计算总数和平均值。</li><li>模拟GROUP语句中的函数FIRST()和LAST()。</li><li>对大量数据做一些数据计算。</li><li>计算一个大表的MD5散列值。</li><li>编写一个样本处理函数，当样本中的数值超过某个边界值的时候将其变成0。</li><li>模拟读/写游标。</li><li>在SHOW语句的WHERE子句中加入变量值。<br>优化排名语句：</li></ul><p>使用用户自定义变量的一个重要特性是你可以在给一个变量赋值的同时使用这个变量。换句话说，用户自定义变量的赋值具有“左值”特性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果把创建高性能应用程序比作是一个环环相扣的“难题”，除了前面介绍的schema、索引和查询语句设计之外，查询优化应该是解开“难题”的最后一步了。要想写一个好的查询，你必须要理解schema设计、索引设计等，反之亦然。</p><p>理解查询是如何被执行的以及时间都消耗在哪些地方，这依然是前面我们介绍的响应时间的一部分。再加上一些诸如解析和优化过程的知识，就可以更进一步地理解上一章讨论的MySQL如何访问表和索引的内容了。这也从另一个维度帮助读者理解MySQL在访问表和索引时查询和索引的关系。</p><p>优化通常都需要三管齐下：不做、少做、快速地做。我们希望这里的案例能够帮助你将理论和实践联系起来。</p><p>除了这些基础的手段，包括查询、表结构、索引等，MySQL还有一些高级的特性可以帮助你优化应用，例如分区，分区和索引有些类似但是原理不同。MySQL还支持查询缓存，它可以帮你缓存查询结果，当完全相同的查询再次执行时，直接使用缓存结果（回想一下，“不做”）。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引学习和总结</title>
      <link href="/posts/8d4e2d9e/"/>
      <url>/posts/8d4e2d9e/</url>
      
        <content type="html"><![CDATA[<h1 id="创建高性能的索引"><a href="#创建高性能的索引" class="headerlink" title="创建高性能的索引"></a>创建高性能的索引</h1><h2 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h2><p>定义：索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种<strong>存储结构</strong>，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的<strong>逻辑指针清单</strong>。</p><h3 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h3><ul><li>B-Tree索引：B-Tree数据结构来存储数据，顺序存储、适合范围数据、适用于全键值、键值范围或键前缀查找。</li><li>哈希索引：基于哈希表实现，只有精确有效。</li><li>空间数据索引（R-Tree）：支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无须前缀查询。空间索引会从所有维度来索引数据。</li><li>全文索引：一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。</li><li>其他类型索引：例如，分形树索引、聚簇索引、覆盖索引等</li></ul><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><pre><code>1、索引大大减少了服务器需要扫描的数据量。2、索引可以帮助服务器避免排序和临时表。3、索引可以将随机I/O变为顺序I/O。</code></pre><h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><pre><code>1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</code></pre><h2 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h2><h3 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h3><p>“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。</p><h3 id="前缀索引和索引的选择性"><a href="#前缀索引和索引的选择性" class="headerlink" title="前缀索引和索引的选择性"></a>前缀索引和索引的选择性</h3><p>索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指，不重复的索引值，索引的选择性越高则查询效率越高。</p><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><h3 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h3><p>当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化WHERE条件的查找。在这种情况下，这样设计的索引确实能够最快地过滤出需要的行，对于在WHERE子句中只使用了索引部分前缀列的查询来说选择性也更高。然而，性能不只是依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值的分布有关。可能需要根据那些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性最高。</p><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式。</p><h4 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h4><pre><code>1、可以把相关数据保存在一起，减少磁盘I/O。2、数据访问更快，因为聚簇索引将索引和数据保存在同一个B-Tree中。3、使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</code></pre><h4 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h4><pre><code>1、聚簇数据最大限度地提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。2、插入速度严重依赖于插入顺序。3、更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。4、基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂（page split）”的问题。5、聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。6、二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。7、二级索引访问需要两次索引查找，而不是一次。因为：二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的</code></pre><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><pre><code>1、索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL就会极大地减少数据访问量。2、因为索引是按照列值顺序存储的（至少在单个页内是如此），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。3、一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。这可能会导致严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。4、由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</code></pre><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><pre><code>1、不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引。2、索引覆盖查询还有很多陷阱可能会导致无法实现优化。MySQL查询优化器会在执行查询前判断是否有一个索引能进行覆盖。假设索引覆盖了WHERE条件中的字段，但不是整个查询涉及的字段。如果条件为假（false），MySQL 5.5和更早的版本也总是会回表获取数据行，尽管并不需要这一行且最终会被过滤掉。</code></pre><h3 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h3><p>MySQL有两种方式可以生成有序的结果：通过排序操作；或者按索引顺序扫描。</p><p>扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在I/O密集型的工作负载时。</p><p>MySQL可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务，这样是最好的。</p><p>只有当索引的列顺序和ORDERBY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。</p><h3 id="压缩（前缀压缩）索引"><a href="#压缩（前缀压缩）索引" class="headerlink" title="压缩（前缀压缩）索引"></a>压缩（前缀压缩）索引</h3><p>默认只压缩字符串，但通过参数设置也可以对整数做压缩。</p><p>压缩块使用更少的空间，代价是某些操作可能更慢。因为每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而只能从头开始扫描。正序的扫描速度还不错，但是如果是倒序扫描——例如ORDER BY DESC——就不是很好了。所有在块中查找某一行的操作平均都需要扫描半个索引块。</p><p>测试表明，对于CPU密集型应用，因为扫描需要随机查找，压缩索引使得MyISAM在索引查找上要慢好几倍。压缩索引的倒序扫描就更慢了。压缩索引需要在CPU内存资源与磁盘之间做权衡。压缩索引可能只需要十分之一大小的磁盘空间，如果是I/O密集型应用，对某些查询带来的好处会比成本多很多。</p><h3 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h3><p>MySQL允许在相同列上创建多个索引，无论是有意的还是无意的。MySQL需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能。</p><p>重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建重复索引，发现以后也应该立即移除。</p><h3 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h3><p>除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引。这样的索引完全是累赘，建议考虑删除</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>有两个工具可以帮助定位未使用的索引。最简单有效的办法是在PerconaServer或者MariaDB中先打开userstates服务器变量（默认是关闭的），然后让服务器正常运行一段时间，再通过查询INFORMATION_SCHEMA.INDEX_STATISTICS就能查到每个索引的使用频率。</p><p>另外，还可以使用Percona Toolkit中的pt-index-usage，该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操作，然后打印出关于索引和查询的报告。这个工具不仅可以找出哪些索引是未使用的，还可以了解查询的执行计划——例如在某些情况有些类似的查询的执行方式不一样，这可以帮助你定位到那些偶尔服务质量差的查询，优化它们以得到一致的性能表现。该工具也可以将结果写入到MySQL的表中，方便查询结果。</p><h3 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h3><p>索引可以让查询锁定更少的行。如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。首先，虽然InnoDB的行锁效率很高，内存使用也很少，但是锁定行的时候仍然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性。</p><h2 id="维护索引和表"><a href="#维护索引和表" class="headerlink" title="维护索引和表"></a>维护索引和表</h2><p>维护表有三个主要的目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。</p><h3 id="找到并修复损坏的表"><a href="#找到并修复损坏的表" class="headerlink" title="找到并修复损坏的表"></a>找到并修复损坏的表</h3><ul><li>CHECK TABLE通常能够找出大多数的表和索引的错误。</li><li>可以使用REPAIR TABLE命令来修复损坏的表，但同样不是所有的存储引擎都支持该命令。</li><li>也可以使用一些存储引擎相关的离线工具，例如myisamchk；或者将数据导出一份，然后再重新导入。不过，如果损坏的是系统区域，或者是表的“行数据”区域，而不是索引，那么上面的办法就没有用了。在这种情况下，可以从备份中恢复表，或者尝试从损坏的数据文件中尽可能地恢复数据。</li></ul><h3 id="更新索引统计信息"><a href="#更新索引统计信息" class="headerlink" title="更新索引统计信息"></a>更新索引统计信息</h3><p>MySQL的查询优化器会通过两个API来了解存储引擎的索引值的分布信息，以决定如何使用索引。第一个API是records_in_range()，通过向存储引擎传入两个边界值获取在这个范围大概有多少条记录。对于某些存储引擎，该接口返回精确值，例如MyISAM；但对于另一些存储引擎则是一个估算值，例如InnoDB。</p><p>第二个API是info()，该接口返回各种类型的数据，包括索引的基数（每个键值有多少条记录）。</p><p>如果存储引擎向优化器提供的扫描行数信息是不准确的数据，或者执行计划本身太复杂以致无法准确地获取各个阶段匹配的行数，那么优化器会使用索引统计信息来估算扫描行数。MySQL优化器使用的是基于成本的模型，而衡量成本的主要指标就是一个查询需要扫描多少行。如果表没有统计信息，或者统计信息不准确，优化器就很有可能做出错误的决定。可以通过运行ANALYZE TABLE来重新生成统计信息解决这个问题。</p><h3 id="减少索引和数据的碎片"><a href="#减少索引和数据的碎片" class="headerlink" title="减少索引和数据的碎片"></a>减少索引和数据的碎片</h3><p>B-Tree索引可能会碎片化，这会降低查询的效率。碎片化的索引可能会以很差或者无序的方式存储在磁盘上。</p><p>根据设计，B-Tree需要随机磁盘访问才能定位到叶子页，所以随机访问是不可避免的。然而，如果叶子页在物理分布上是顺序且紧密的，那么查询的性能就会更好。否则，对于范围查询、索引覆盖扫描等操作来说，速度可能会降低很多倍；对于索引覆盖扫描这一点更加明显。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在MySQL中，大多数情况下都会使用B-Tree索引。<br>在选择索引和编写利用这些索引的查询时，有如下三个原则始终需要记住：</p><ul><li>单行访问是很慢的。特别是在机械硬盘存储中（SSD的随机I/O要快很多，不过这一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引用以提升效率。</li><li>按顺序访问范围数据是很快的，这有两个原因。第一，顺序I/O不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUP BY查询也无须再做排序和将行按组进行聚合计算了。</li><li>索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访问是很慢的。</li></ul><p>总的来说，编写查询语句时应该尽可能选择合适的索引以避免单行查找、尽可能地使用数据原生顺序从而避免额外的排序操作，并尽可能使用索引覆盖查询。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人网站环境搭建</title>
      <link href="/posts/350b6c15/"/>
      <url>/posts/350b6c15/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是一篇详细的 <code>hexo</code> 和 <code>github pages</code> 搭建一个个人独立网站的教程</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在互联网的世界里我们都是一个一个的点，需要连接，渴望关系。想向他人展示自己，寻求认可。同时，我们也需要一个让自己放心可以静下来的地方，修炼自己和自己对话，无疑个人网站是一个不错的选择，没有其他社交软件的喧嚣，能够安心创作，发酵和展示。这篇文章可以带你从0到1完成这样一个网站的建立。</p><h2 id="什么是hexo"><a href="#什么是hexo" class="headerlink" title="什么是hexo"></a>什么是hexo</h2><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub。Hexo同时也是GitHub上的开源项目，参见：<a href="https://github.com/hexojs/hexo">hexojs/hexo</a> 如果想要更加全面的了解Hexo，可以到其官网 Hexo 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><h3 id="这是我的个人网站的效果：仟与仟寻"><a href="#这是我的个人网站的效果：仟与仟寻" class="headerlink" title="这是我的个人网站的效果：仟与仟寻"></a>这是我的个人网站的效果：<a href="https://spb512.github.io/">仟与仟寻</a></h3><p>废话不多说，现在开始搭建</p><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><ul><li>获得个人域名</li><li>github创建个人账户</li><li>安装git</li><li>安装hexo</li><li>建立推送地址</li><li>绑定域名</li><li>更换主题</li><li>了解markdown基本语法</li><li>使用网站发布文章</li><li>寻找图床</li><li>个性化设置</li><li>其他</li><li>附录</li></ul><h3 id="获得个人域名"><a href="#获得个人域名" class="headerlink" title="获得个人域名"></a>获得个人域名</h3><p>域名是网站的入口，也是网站的第一印象，比如饿了么的官网的域名是：<code>https://www.ele.me/ </code>，很巧妙。常见的有com,cn,net,org等后缀，也有小众的xyz,me,io等后缀，根据你自己的喜好，选择不同的后缀，比如我选择就是常见的com后缀。很多小众奇特的后缀在大陆是没办法备案的，网站也就无法上线。然而使用GitHub托管我们的网站，完全不需要备案，因为托管我们的网站内容的服务器在美国，而且在国内备案流程也比较繁杂，时间需要一周左右。申请域名的地方有很多，这里推荐阿里云：<a href="https://www.aliyun.com/">阿里云-为了无法计算的价值</a>申请入口：<a href="https://wanwang.aliyun.com/domain/">域名注册</a>购买域名这也是我们整个搭建过程中惟一一个需要花钱的地方。如果你已经有了空闲域名就无需购买，直接使用即可。</p><h3 id="GitHub创建个人账号"><a href="#GitHub创建个人账号" class="headerlink" title="GitHub创建个人账号"></a>GitHub创建个人账号</h3><p>登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号<a href="https://github.com/">官网</a>点击GitHub中的New  repository创建新仓库，仓库名应该为：<code>http://用户名.github.io</code> 这个用户名使用你的GitHub帐号名称代替，这是固定写法，只有和账号名称相同才会生成对外访问链接</p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>什么是Git ?简单来说Git是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用Git同步到GitHub上。 从Git官网下载：<a href="https://git-scm.com/download/win">Git - Downloading Package</a> 现在的机子基本都是64位的，选择64位的安装包，下载后安装，在命令行里输入git测试是否安装成功，若安装失败，参看其他详细的Git安装教程。安装成功后，将你的Git与GitHub帐号绑定，鼠标右击打开Git Bash</p><p><a href="https://i.loli.net/2019/07/08/5d234c3e30b1644228.png"><img src="https://i.loli.net/2019/07/08/5d234c3e30b1644228.png" alt="微信截图_20190708215740.png"></a></p><p>或者在菜单里搜索Git Bash，设置user.name和user.email配置信息：</p><pre class="line-numbers language-bush" data-language="bush"><code class="language-bush">git config --global user.name "你的GitHub用户名"git config --global user.email "你的GitHub注册邮箱"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>生成ssh密钥文件：</p><pre class="line-numbers language-bush" data-language="bush"><code class="language-bush">ssh-keygen -t rsa -C "你的GitHub注册邮箱"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后直接三个回车即可，默认不需要设置密码<br>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制</p><p><img src="https://i.loli.net/2019/07/08/5d234ea5299f248532.png" alt="微信截图_20190708220811.png"></p><p>打开<a href="https://github.com/settings/keys">GitHub_Settings_keys</a> 页面，新建new SSH Key<br><img src="https://pic1.zhimg.com/80/v2-72a3f22c080e99343c3cc4aabce10e3c_hd.jpg"><br>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。<br>在Git Bash中检测GitHub公钥设置是否成功，输入 <code>ssh git@github.com</code> ：</p><p><img src="https://pic2.zhimg.com/50/v2-da481ffa686410becd4186c656b4ebd6_hd.jpg"></p><p>如上则说明成功。这里之所以设置GitHub密钥原因是，通过非对称加密的公钥与私钥来完成加密，公钥放置在GitHub上，私钥放置在自己的电脑里。GitHub要求每次推送代码都是合法用户，所以每次推送都需要输入账号密码验证推送用户是否是合法用户，为了省去每次输入密码的步骤，采用了ssh，当你推送的时候，git就会匹配你的私钥跟GitHub上面的公钥是否是配对的，若是匹配就认为你是合法用户，则允许推送。这样可以保证每次的推送都是正确合法的。</p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Hexo基于Node.js，Node.js下载地址：<a href="https://nodejs.org/en/download/">Download | Node.js</a> 下载安装包，注意安装Node.js会包含环境变量及npm的安装，安装后，检测Node.js是否安装成功，在命令行中输入 node -v :</p><p><img src="https://pic2.zhimg.com/80/v2-bede250b8456df92475b455fda8c1dd9_hd.jpg"></p><p>如果看到版本号那就表示安装成功了。到这了，安装Hexo的环境已经全部搭建完成。</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>Hexo就是我们的个人博客网站的框架， 这里需要自己在电脑常里创建一个文件夹，可以命名为Blog，Hexo框架与以后你自己发布的网页都在这个文件夹中。创建好后，进入文件夹中，按住shift键，右击鼠标点击命令行<br><img src="https://pic1.zhimg.com/80/v2-a5450a466c0927c25dff8ad6f1d2046c_hd.jpg"><br>使用npm命令安装Hexo，输入：</p><p><code>npm install -g hexo-cli</code><br>这个安装时间较长耐心等待，安装完成后，初始化我们的博客，输入：</p><p><code>hexo init blog</code><br>注意，这里的命令都是作用在刚刚创建的Blog文件夹中。<br>为了检测我们的网站雏形，分别按顺序输入以下三条命令：</p><pre class="line-numbers language-bush" data-language="bush"><code class="language-bush">hexo new test_my_sitehexo ghexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些命令在后面作介绍，完成后，打开浏览器输入地址：</p><p><img src="https://pic4.zhimg.com/80/v2-123e73c0630d299b1c856d99b04b55bb_hd.jpg"></p><p><code>localhost:4000</code><br>如果看到界面，那就表示安装成功了</p><p>现在来介绍常用的Hexo 命令</p><p>npm install hexo -g #安装Hexo<br>npm update hexo -g #升级<br>hexo init #初始化博客</p><p>命令简写<br>hexo n “我的博客” == hexo new “我的博客” #新建文章<br>hexo g == hexo generate #生成<br>hexo s == hexo server #启动服务预览<br>hexo d == hexo deploy #部署</p><p>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP<br>hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</p><p>刚刚的三个命令依次是新建一篇博客文章、生成网页、在本地预览的操作。</p><h3 id="推送网站"><a href="#推送网站" class="headerlink" title="推送网站"></a>推送网站</h3><p>上面只是在本地预览，接下来要做的就是就是推送网站，也就是发布网站，让我们的网站可以被更多的人访问。在设置之前，需要解释一个概念，在blog根目录里的_config.yml文件称为站点配置文件，如下图</p><p><img src="https://pic2.zhimg.com/80/v2-cb1fd5e5a2e73f513234e434724c7c55_hd.jpg"></p><p>进入根目录里的themes文件夹，里面也有个_config.yml文件，这个称为主题配置文件，如下图</p><p><img src="https://pic4.zhimg.com/80/v2-4252029e5634bf91c7d58916ae2b8ac3_hd.jpg"><br>下一步将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：</p><pre class="line-numbers language-none"><code class="language-none">deploy: type: gitrepo: 这里填入你之前在GitHub上创建仓库的完整路径，记得加上 .gitbranch: master参考如下：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://pic1.zhimg.com/80/v2-279ac5149b577f04dc099defbb12eaa8_hd.jpg"><br>保存站点配置文件。</p><p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。最后安装Git部署插件，输入命令：</p><p><code>npm install hexo-deployer-git --save</code></p><p>这时，我们分别输入三条命令：</p><pre class="line-numbers language-bush" data-language="bush"><code class="language-bush">hexo clean hexo g hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 <a href="http://xxxx.github.io/">http://xxxx.github.io</a> (知乎排版可能会出现”http://“字样，参考下图) 比如我的xxxx就是我的GitHub用户名：<br>你就会发现你的博客已经上线了，可以在网络上被访问了。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>虽然在Internet上可以访问我们的网站，但是网址是GitHub提供的:<a href="http://xxxx.github.io/">http://xxxx.github.io</a> (知乎排版可能会出现”http://“字样) 而我们想使用我们自己的个性化域名，这就需要绑定我们自己的域名。这里演示的是在阿里云万网的域名绑定，在国内主流的域名代理厂商也就阿里云和腾讯云。登录到阿里云，进入管理控制台的域名列表，找到你的个性化域名，进入解析</p><p><img src="https://pic3.zhimg.com/80/v2-47323ad4490e206aef93a3d68f0670b6_hd.jpg"><br>然后添加解析<br><img src="https://pic3.zhimg.com/80/v2-40222b3a295bb692aac22829a8ec3be2_hd.jpg"><br>这样配置无论输入是否有WWW都可以访问到<br>不添加www 有两种方法，其中第2种部分域名注册商不支持，如果不支持就选择第1种<br>1.主机名填写@或者空着，类型 A记录，记录值填写ip<br>2.主机名填写@或者空着，类型 cname，记录值填写笔名解析地址<br>添加www 主机名填写 www 类型cname，记录值填写笔名解析地址<br>解析之后等dns刷新解析生效即可</p><p>包括添加三条解析记录，192.30.252.153是GitHub的地址，你也可以ping你的 <a href="http://xxxx.github.io/">http://xxxx.github.io</a> 的ip地址，填入进去。第三个记录类型是CNAME，CNAME的记录值是：你的用户名.<a href="http://github.io/">http://github.io</a> 这里千万别弄错了。第二步，登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名<br><img src="https://pic4.zhimg.com/80/v2-85ba6dda906f22dea4c03df2b47d994b_hd.jpg"><br>点击save保存。第三步，进入本地博客文件夹 ，进入blog/source目录下，创建一个记事本文件，输入你的域名，对，只要写进你自己的域名即可。如果带有www，那么以后访问的时候必须带有www完整的域名才可以访问，但如果不带有www，以后访问的时候带不带www都可以访问。所以建议，不要带有www。这里我还是写了www(不建议带有www):<br><img src="https://pic1.zhimg.com/80/v2-79abfff91af3f520e24cb91acf6aa994_hd.jpg"><br>保存，命名为CNAME ，注意保存成所有文件而不是txt文件。</p><p>完成这三步，进入blog目录中，按住shift键右击打开命令行，依次输入：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">hexo cleanhexo ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这时候打开浏览器在地址栏输入你的个性化域名将会直接进入你自己搭建的网站。</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>如果你不喜欢Hexo默认的主题，可以更换不同的主题，主题传送门：Themes 我自己使用的是Next主题，可以在blog目录中的themes文件夹中查看你自己主题是什么。现在把默认主题更改成Next主题，在blog目录中（就是命令行的位置处于blog目录）打开命令行输入：</p><p><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code><br><img src="https://pic1.zhimg.com/80/v2-b1997377e82408cb15b485c65ae00f70_hd.jpg"><br>打开主题的_config.yml配置文件，不是站点主题文件，找到Scheme Settings<br><img src="https://pic2.zhimg.com/80/v2-1ac152c4aabe4c10b762ee27552f1105_hd.jpg"><br>next主题有三个样式，我用的是Pisces，你们可以自己试试看，选择你自己喜欢的样式（只需要把行首的#去除，#是注释），选择好后，再次部署网站，hexo g、hexo d，查看效果。选择其他主题，按照上述过程即可实现。</p><h3 id="初识Markdown语法"><a href="#初识Markdown语法" class="headerlink" title="初识Markdown语法"></a>初识Markdown语法</h3><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown语法简洁明了、容易掌握，而且功能比纯文本更强，因此写博客使用它，可以让用户更加专注的写文章，而不需要费尽心力的考虑样式，相对于html已经算是轻量级语言，像有道云笔记也支持Markdown写作。并且Markdown完全兼容html，也就是可以在文章里直接插入html代码。比如给博文添加音乐，就可以直接把音乐的外链html代码插入文章中。具体语法参看：<a href="https://www.appinn.com/markdown/">Markdown 语法说明(简体中文版)</a> 可以说十分钟就可以入门。当然，工欲善其事必先利其器，选择一个好的Markdown编辑器也是非常重要的，这里推荐<a href="https://link.zhihu.com/?target=http://code52.org/DownmarkerWPF/">MarkPad</a> 和<a href="https://link.zhihu.com/?target=http://www.markdownpad.com/">The Markdown Editor for Windows</a> ，这是带有预览效果的编辑器，也可以使用本地的文本编辑器，更多的Markdown的语法与编辑器自己可以搜索了解。</p><h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><p><img src="https://pic1.zhimg.com/80/v2-4f96cd03a88e68b8ae86c38bfb0808ac_hd.jpg"></p><p>通过带有预览样式的Markdown编辑器实时预览书写的博文样式，也可以通过命令 hexo s –debug 在本地浏览器的localhost:4000 预览博文效果。写好博文并且样式无误后，通过hexo g、hexo d 生成、部署网页。随后可以在浏览器中输入域名浏览。</p><h3 id="寻找图床"><a href="#寻找图床" class="headerlink" title="寻找图床"></a>寻找图床</h3><p>图床，当博文中有图片时，若是少量图片，可以直接把图片存放在source文件夹中，但这显然不合理的，因为图片会占据大量的存储的空间，加载的时候相对缓慢 ，这时考虑把博文里的图片上传到某一网站，然后获得外部链接，使用Markdown语法，<img src="/%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5" alt="图片信息"> 完成图片的插入，这种网站就被成为图床。常见的简易的图床网站有：<a href="https://link.zhihu.com/?target=http://www.tietuku.com/">贴图库图片外链</a> 国内算比较好的图床我认为有两个：新浪微博和 <a href="https://link.zhihu.com/?target=https://www.qiniu.com/">七牛云</a> ，七牛云的使用方法可以参看其他文章。还有<a href="https://sm.ms/">sm.ms</a>也还可可以。图床最重要的就是稳定速度快，所以在挑选图床的时候一定要仔细，下图是博文插入图片，使用图床外链的示例：<br><img src="https://pic4.zhimg.com/80/v2-92372e522595af139ace5f371aae3ff3_hd.jpg"></p><h3 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h3><p>所谓的个性化设置就是根据个人需要添加不同的插件及功能。</p><p>基本的有：</p><p>在站点配置文件_config.yml修改基本的站点信息<br><img src="https://pic4.zhimg.com/80/v2-78bc0e4e6498c9c3cb269b3254d8379f_hd.jpg"><br>依次是网站标题、副标题、网站描述、作者、网站头像外部链接、网站语言、时区等。</p><p>在主题配置文件_config.yml修改基本的主题信息，如：<br><img src="https://pic2.zhimg.com/80/v2-451c5cb2fd6516650ad8ca608031bf0d_hd.jpg"><br>博文打赏的微信、支付宝二维码图片，这里我是直接把这两张放在根目录的source文件夹中，并没有使用图床外链。<br><img src="https://pic2.zhimg.com/80/v2-69bbc45e973eb6916e08187ed8b33a55_hd.jpg"><br>社交外链的设置，即在侧栏展示你的个人社交网站信息。<br><img src="https://pic4.zhimg.com/80/v2-5b3f6e02e0d3a0cdb685a4d2fd2718cb_hd.jpg"><br>博文分享的插件jiathis，值设置为true。在配置文件中有很多的个性化设置，可以自尝试更多的修改。</p><ul><li>进阶个性化：</li></ul><p>添加网易云音乐</p><p>打开网页版的网易云音乐，选择喜欢的音乐，点击生成外链播放器</p><p><img src="https://pic2.zhimg.com/80/v2-fcb7d44ccdca3760c98db0d13817f2b5_hd.jpg"><br>复制外链的代码<br><img src="https://pic4.zhimg.com/80/v2-16eec195312cde7b1d257fac6f3c8d0b_hd.jpg"><br>比如在侧栏插入这首歌的音乐播放器，修改 blog\themes\next\layout_macro的sidebar.swig文件，添加刚刚复制的外链代码<br><img src="https://pic4.zhimg.com/80/v2-03db51002497b27e4d5888e0efd577c7_hd.jpg"><br>重新生成、部署网页，效果如下<br><img src="https://pic2.zhimg.com/80/v2-3d587bf919df92db38e2608f034e50f1_hd.jpg"></p><ul><li>设置背景<br>把你挑选的背景图片命名为：background.jpg，放在blog\themes\next\source\images里，在blog\themes\next\source\css_custom文件的custom.styl首部添加：</li></ul><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">body</span> <span class="token punctuation">{</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>/images/background.jpg<span class="token punctuation">)</span></span> fixed<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>background-attachment: fixed;是固定背景图片。</p><p>这是设置一张静态图片作为背景，其实Next主题自带有动态的背景效果，修改主题配置文件中的canvas_nest: false为canvas_nest: true即可。</p><p>增加侧栏菜单条目<br>默认的侧栏菜单条目有：首页、归档、标签、关于、搜索等。如果你想要增加其他的菜单条目，修改主题配置文件_config.yml里的Menu Settings中的menu和menu_icons两个地方<br><img src="https://pic3.zhimg.com/80/v2-666a22fedbba95d979eeb26e52fc29e2_hd.jpg"><br>其中menu里是配置菜单项对应的页面位置（如：/love），menu_icons对应菜单项的图标，这里的图标是来自于<a href="https://link.zhihu.com/?target=http://fontawesome.io/">Font Awesome</a> ，所以你需要在Font Awesome网站上找到你需要的icon，然后把该icon的名字写在menu_icons对应菜单名后面，注意冒号有一个英文输入状态的空格。设置好后，在命令行里输入：</p><p><code>hexo new page "你所要增加的菜单项名称（要和你在menu中的填写要匹配）"</code><br>新建的页面在博客根目录下的source文件里，这时你就可以对新建的页面自定义设计。</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
